package kg.AD.activity;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.util.Log;

import kg.AD.R;

public class Methods extends AppCompatActivity {

    private final static String TAG = "Methods";

    /**
     * первый метод, с которого начинается выполнение activity.
     * В этом методе activity переходит в состояние Created.
     * Этот метод обязательно должен быть определен в классе activity.
     * В нем производится первоначальная настройка activity.
     * В частности, создаются объекты визуального интерфейса.
     * Этот метод получает объект Bundle, который содержит прежнее состояние activity, если оно было сохранено.
     * Если activity заново создается, то данный объект имеет значение null.
     * Если же activity уже ранее была создана, но находилась в приостановленном состоянии,
     * то bundle содержит связанную с activity информацию.
     */
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_methods);
        Log.d(TAG, "onCreate");
    }

    /**
     * В методе осуществляется подготовка к выводу activity на экран устройства.
     * Как правило, этот метод не требует переопределения, а всю работу производит встроенный код.
     * После завершения работы метода activity отображается на экране, вызывается метод onResume,
     * а activity переходит в состояние Resumed.
     */
    @Override
    protected void onStart() {
        super.onStart();
        Log.d(TAG, "onStart");
    }

    /**
     * После завершения метода onStart() вызывается этот метод,
     * который призван восстанавливать сохраненное состояние из объекта Bundle, который передается в качестве параметра.
     * Но следует учитывать, что этот метод вызывается только тогда,
     * когда Bundle не равен null и содержит ранее сохраненное состояние.
     * Так, при первом запуске приложения этот объект Bundle будет иметь значение null,
     * поэтому и метод onRestoreInstanceState не будет вызываться.
     */
    @Override
    protected void onRestoreInstanceState(@NonNull Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        Log.d(TAG, "onRestoreInstanceState");
    }

    /**
     * При вызове этого метода activity переходит в состояние Resumed,а пользователь может с ней взаимодействовать.
     * И собственно activity остается в этом состоянии, пока она не потеряет фокус,
     * например, вследствии переключения на другую activity или просто из-за выключения экрана устройства.
     */
    @Override
    protected void onResume() {
        super.onResume();
        Log.d(TAG, "onResume");
    }

    /**
     * Если пользователь решит перейти к другой activity, то система вызывает этот метод.
     * В методе можно освобождать используемые ресурсы, приостанавливать процессы,
     * например, воспроизведение аудио, анимаций, останавливать работу камеры (если она используется) и т.д.,
     * чтобы они меньше сказывались на производительность системы.
     * Но надо учитывать, что на работу данного метода отводится очень мало времени,
     * поэтому не стоит здесь сохранять какие-то данные, особенно если при этом требуется обращение к сети,
     * например, отправка данных по интернету, или обращение к базе данных.
     * После выполнения этого метода activity становится невидимой, не отображается на экране, но она все еще активна.
     * И если пользователь решит вернуться к этой activity,
     * то система вызовет снова метод onResume, и activity снова появится на экране.
     * Другой вариант работы может возникнуть, если вдруг система видит,
     * что для работы активных приложений необходимо больше памяти.
     * И система может сама завершить полностью работу activity, которая невидима и находится в фоне.
     * Либо пользователь может нажать на кнопку Back (Назад). В этом случае у activity вызывается метод onStop.
     */
    @Override
    protected void onPause() {
        super.onPause();
        Log.d(TAG, "onPause");
    }

    /**
     * Этот метод вызывается после метода onPause(), но до вызова onStop().
     * В onSaveInstanceState производится сохранение состояния приложения в передаваемый в качестве параметра объект Bundle.
     */
    @Override
    protected void onSaveInstanceState(@NonNull Bundle outState) {
        super.onSaveInstanceState(outState);
        Log.d(TAG, "onSaveInstanceState");
    }

    /**
     * В этом методе activity переходит в состояние Stopped.
     * В методе onStop следует особождать используемые ресурсы,
     * которые не нужны пользователю, когда он не взаимодействует с activity.
     * Здесь также можно сохранять данные, например, в базу данных.
     * При этом во время состояния Stopped activity остается в памяти устройства,
     * сохраняется состояние всех элементов интерфейса.
     * К примеру, если в текстовое поле EditText был введен какой-то текст,
     * то после возобновления работы activity и перехода ее в состояние Resumed мы вновь увидим в текстовом поле ранее введенный текст.
     * * Если после вызова метода onStop пользователь решит вернуться к прежней activity, тогда система вызовет метод onRestart.
     * * Если же activity вовсе завершила свою работу, например, из-за закрытия приложения, то вызывается метод onDestroy().
     */
    @Override
    protected void onStop() {
        super.onStop();
        Log.d(TAG, "onStop");
    }

    /**
     * Если после вызова метода onStop пользователь решит вернуться к прежней activity, тогда система вызовет метод onRestart.
     * Если же activity вовсе завершила свою работу, например, из-за закрытия приложения, то вызывается метод onDestroy().
     */
    @Override
    protected void onRestart() {
        super.onRestart();
        Log.d(TAG, "onRestart");
    }

    /**
     * Ну и завершается работа активности вызовом метода onDestroy, который возникает либо,
     * если система решит убить activity, либо при вызове метода finish().
     * Также следует отметить,
     * что при изменении ориентации экрана система завершает activity и затем создает ее заново, вызывая метод onCreate.
     */
    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.d(TAG, "onDestroy");
    }
}